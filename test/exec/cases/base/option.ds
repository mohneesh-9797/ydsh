function opt($v : Int) : Option<String> {
    return $v > -1 ? "hello" : new Option<String>()
}

# boolean cast
assert $opt(1)

assert not $opt(-2)

if $opt(1) {
    assert $true
} else {
    assert $false
}

var c = 0
for(var i = 4; $opt($i); $i--) {
    $c++
}
assert $c == 5

assert $opt(5) ? $true : $false
assert $opt(-3) ? $false : $true

assert $opt(45) as Boolean
assert not ($opt(-90) as Boolean)


# unwrap
assert $opt(45)! == "hello"
assert (34 as Option<Int>)! == 34

var in = $false
try {
    assert $opt(-43)! == "hello"
} catch $e {
    $in = $true
    assert $e is UnwrappingError
}
assert $in


# assign
var o = $opt(45)
$o = "world"
assert $o! == "world"

$o = new String!()
$o = "34"
assert $o && $o! == "34"


# collection with option value
assert [23 as Int!] as String == '[23]'
try { [34 : new Int!()] as String } catch $e { assert $e is UnwrappingError }
try { (34, new Boolean!()) as String } catch $e { assert $e is UnwrappingError }

assert "${[3 as Int!]}" == '3'
try { "${[1u : new String!()]}" }catch $e { assert $e is UnwrappingError }
try { "${(2, $false, new Error!())}" }  catch $e { assert $e is UnwrappingError }

assert "$(echo ${[$false as Boolean!]})" == 'false'
try { echo ${['s' : new Float!()]}; }  catch $e { assert $e is UnwrappingError }
try { echo ${(new Byte!(),)}; } catch $e { assert $e is UnwrappingError }